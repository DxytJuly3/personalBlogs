---
layout: '../../layouts/MarkdownPost.astro'
title: '[Linux] '
pubDate: 2024-01-08
description: ''
author: '七月.cc'
cover:
    url: 'https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401080147048.webp'
    square: 'https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401080147048.webp'
    alt: 'cover'
tags: ["Linux网络", "传输层", "协议", "TCP", "约字 -- 阅读时间≈分钟"]
theme: 'light'
featured: false
---

上一篇文章, 针对`UDP`协议的格式、数据等内容做了一些简单的介绍. 并且提到, 在网络协议栈`TCP/IP`模型的传输层中, 有两个最具代表性的协议: `UDP`和`TCP`

本篇文章就简单介绍一下`TCP`协议

# `TCP`协议

`TCP`协议, 完整的称呼其实叫: **传输控制协议(Transmission Control Protocol)**

从名字就可以看出来, `TCP`协议 实际是可以对数据的传输进行详细控制的

## `TCP`协议格式

使用`TCP`协议进行通信, 操作系统会对数据添加`TCP`的协议报头, 那么`TCP`协议的格式是这样的:

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20240116205033001.webp)

可以看到, `TCP`协议报头要比`UDP`协议报头复杂的多

在介绍`UDP`协议时提到过, `TCP/IP`协议栈的每一层在进行数据传输时, 都需要考虑三个内容: **封装、解包和分用**

`TCP`协议报头中有两个熟悉的面孔: **16位源端口号 和 16位目的端口号**, 这两个数据的作用就不用多做介绍了, 是为了解决 **分用** 的问题的

### `TCP`协议的封装和解包

`UDP`协议的报头采用了8字节的固定长度, 所以可以很好的解决封装和解包的问题

而在`TCP`报文中, 我们可以看到在前`20字节`之外, 还有一个占有`n字节`的选项. 这`n字节`的部分是不固定的, 并且也属于`TCP`报头的内容

**`TCP`报头没有选项时一共`20字节`, 这20字节的数据是必须的, 被称为标准长度**

`TCP`协议在使用时, 报头的长度可能90%的情况都是标准长度(20字节). 即使选项不是必须的, 也不能忽略那`n字节`的选项长度

也就是说, **`TCP`报头的长度最少为`20字节`, 但是并不固定 可能会更大.**

既然`TCP`报头长度不固定, 那么怎么解决封装和解包的问题呢?

观察`TCP`报文格式可以发现, 在报头的`第13字节(4位空间)`处, 存储的数据表示的是 **首部长度**. 这个**首部长度, 实际就表示`TCP`协议报头的长度**

但是, 又有一个问题: `TCP`报头长度最少`20字节`, 但是报头中表示首部长度的数据只有4位, 最多也就能表示16个数据(0000~1111), 好像不太够用

> 4位空间:
>
> `0000` `0001` `0010` `0011`
>
> `0100` `0101` `0110` `0111`
>
> `1000` `1001` `1010` `1011`
>
> `1100` `1101` `1110` `1111`

实际上是够用的, 因为 **这`4位 16个数据`的单位并不是`1字节`, 而是`4字节`. 那么也就是说, 这四位数据最多可以表示 `60字节`, 即 `TCP`首部长度最大为`60字节`**

但是, 不要忽略一个细节, `TCP`报头的标准长度为`20字节`, 也就是说最少为`20字节`. 那么, 实际上这 **4位表示首部长度的数据** 至少是`0101(5)`

既然`TCP`报头中存储有表示报头长度的数据, 那么就可以很好的解决封装和解包的问题

> 问题:
>
> `TCP`报头并没有表示报文总长度的数据, 那么接收端如何接收到报文中所包含的所有数据呢
>
> 这个问题要等到介绍网络`IP`层才会有一个答案

## `TCP`的可靠性

无论是`UDP/TCP Socket`的介绍, 还是上一篇文章中关于`UDP`协议的介绍, 文章中总提到: `UDP`协议是不可靠的, `TCP`协议是可靠的

那么, 究竟什么是不可靠? 什么是可靠?

什么是不可靠呢?

实际上我们已经提到过什么是不可靠的表现, 比如: 出现丢包、乱序、检验失败等情况, 并且不对这种情况做出处理. 这些情况, 在`UDP`协议中可能会经常出现. 不过, 既然使用了那么这些不可靠一定就不会对服务造成很大的影响

那么, 可靠就与不可靠相反了

`UDP`协议不会对丢包、检验失败等情况做出处理, 即使接收方没有正常收到数据, 接收方也不会有任何反应, 发送方更不会做出弥补. 我们说这是`UDP`协议更简单的一些代价

而`TCP`协议则不同. 使用`TCP`协议通信时, 如果出现了丢包等接收方没有收到数据的情况, `TCP`协议会有一些处理, 比如: 重传、控制流量等

那么, `TCP`协议是如何维护数据传输的可靠性的呢?

### `TCP`协议的确认应答机制

`TCP`协议会对接收方没有正常收到数据的情况做出弥补. 但是要实现这样的功能的第一个问题就是: **在这样的长距离通信中, 发送方(A)该如何确认发送的数据是丢了还是接收到了?**

答案是, **接收方(B)的回应**. 只要B收到数据之后, 给A发送一个回应, 那么A就可以确认数据已经发送到了

**即, 只要发送方 收到了应答, 那么发送方就可以确认刚刚发送的消息一定已经被收到了**

不过, **B发送的回应, B如何确认A是否收到了呢?**

答案是相同的, 如果 A收到B的回应之后, 再给B发送一个回应, 那么B就可以确认A收到了

就像这样:

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20240117001126901.webp)

你会发现, 如果想要做到每条消息都确定对方收到了, 是不可能的

因为 **在这样的长距离通信中, 永远有一条最新的消息是不能被确认的、没有应答的**

那么, 也就是说`TCP`协议也不是完全的可靠, 并且没有协议可以做到完全百分百的可靠

但是, `TCP`协议可以做到局部的可靠. 只要保证最新消息之前的消息都有了应答, 那么最新消息之前的数据就可以确定都已经接收到. 这就是`TCP`协议的可靠性

这样的机制, 被称为 **`TCP`协议的确认应答机制(ACK)**

---

不过, 这里又出现了其他问题: **使用`TCP`协议进行通信, 绝大多数情况下发送的报文是有很多个的. 那么,  发送方如何知道, 接收方应答的是哪一个报文呢?**

> 这个问题是什么意思呢? 
>
> `TCP`协议为了维护可靠性, 是有确认应答机制的. 不过, 在使用`TCP`进行通信时, 很可能会在短时间内发送很多个报文, 接收方实际并不会对接收到的每一个报文都单独做出应答, 而是在接收到多个报文之后, 再进行统一的应答(即, 如果短时间内发送10个报文, 接收方的应答一般不会是10个, 接收方很可能在收到多个报文之后, 才应答一次, 这样可以提高效率), 这个机制叫做 **积累确认 或 积累应答**
>
> 这样就出现了, 发送方发送了多个报文, 却只收到了一个应答 的情况. 那么, 发送方 怎么知道接收方应答的哪一个报文呢?

`TCP`协议报头中, 有两个字段: **32位序号 和 32位确认序号**. 这两个字段, 可以解决上面这个问题

`TCP`协议在发送数据 填充报头时, 会填充序号. 那么, 接收方接收到报文之后, 会根据报文的报头中填充的序号, 做出对应的应答. 即, 接收方 会在应答报文的报头中, 填充对应的确认序号

**确认序号, 一般为接收到的报文序号+1, 表示 确认序号之前的所有序号的报文都已经接收到, 也同时表示接收方期望下次开始接收报文的序号**

用图片可以很形象的表示出来:

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401171656408.webp)

同时, **接收端还可以通过接收到报文的序号对报文进行排序**, **这就是`TCP`协议报头中 32位序号 和 32位确认序号 这两个字段的作用**

从这两个序号的作用可以看出来, **发送端报头中的序号 与 接收端报头中的确认序号 是配套使用的**. 那么, 也就意味着, **同一个报文的报头中, 序号与确认序号是相互独立、互不影响的**. 这也是 **`TCP`协议全双工** 的一种体现, 因为同一个报文中的序号和确认序号是相互独立的, 所以同一个报文中可以同时填充序号和确认序号, 那么就表示这个报文在具有应答功能的同时, 还携带有数据进行发送

> 按照这样, 如果发送端发送了`1~10`序号的报文, 但是接收端只收到了`1~6`和`8~10`, 没有收到`7`
>
> 那么, 接收端应答中的 确认序号应该填充`7`, 因为`7`之前序号的报文都收到了

> `TCP`协议通信时, 报文的起始序号实际是随机的. 并且, 后续的序号是与 起始序号和报文本身 有关
>
> 这样可以防止有人通过 模仿序号篡改数据 进行网络攻击

### `TCP`协议的缓冲区及流量控制

在介绍`UDP`协议的文章中提到过, 无论是`UDP`协议还是`TCP`协议. 在发送报文时, 都不会直接将数据发送到网络, 而是将数据放入内核针对协议实现的 **发送缓冲区** 中(`UDP`没有真正的发送缓冲区). 接收数据也是相同的, 操作系统会将报文放入 **接收缓冲区** 中

`UDP`协议 在内核中没有实现真正的发送缓冲区, 只有接收缓冲区

而 `TCP`协议 则在内核中真正实现了 发送缓冲区和接收缓冲区

那么, 两个主机在使用`TCP`协议进行通信, 使用`write()/send()`和`read()/recv()`接口实现数据发送和接收所执行的操作, 简单理解可以看作:

![|wide](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401172030081.webp)

> ```cpp
> ssize_t write(int fd, const void *buf, size_t count);
> ssize_t send(int sockfd, const void *buf, size_t len, int flags);
> 
> ssize_t read(int fd, void *buf, size_t count);
> ssize_t recv(int sockfd, void *buf, size_t len, int flags);
> ```
>
> 这4个系统调用, 都需要指定一个`buf`

即, 使用`TCP`协议进行通信:

调用`write()/send()`发送数据 实际 是将数据 从进程指定的缓冲区中拷贝到了内核中`TCP`的发送缓冲区

调用`read()/recv()`读取数据 实际 是将数据 从内核中`TCP`的接收缓冲区拷贝到了进程指定的缓冲区中

也就是说, `write()/send()`实际并没有将数据发送走, 而只是将数据从用户拷贝到了内核数据中

> 实际上, 常用的`I/O`类函数, 本质上都是拷贝函数
>
> 即使使用`write()`向文件内写数据, 也只是将拷贝数据交给了操作系统, 并不是直接就写入了文件内

因为, `TCP`协议在内核中实现拥有发送缓冲区和接收缓冲区并且互不干扰, 所以`TCP`协议通信是全双工的

并且, 因为`TCP`协议发送数据, 是将数据拷贝到发送缓冲区, 然后由内核中的`TCP`协议自行决策(比如: 什么时候发、发多少、要不要进行一些调整...), 所以这个协议叫做 **传输控制协议(Transmission Control Protocol)**

#### `TCP`的流量控制

`TCP`协议在内核中是拥有发送缓冲区和接收缓冲区的, 那么 既然是缓冲区, 那就一定有一定的大小

并且, `TCP`协议通信是可靠的, 那么对发送出去的数据就不能不管不顾, 不能像`UDP`那样(如果接收缓冲区满了, 再发送过来的数据报就丢掉不管了)

那么, 如果`TCP`协议发送数据过快, 导致接受方的接收缓冲区满了, 怎么办? 继续快速的发送数据, 然后接收方来不及接收 直接丢包不管吗?

`TCP`协议并不会这样. `TCP`协议为了保障通信效率, 拥有自己的流量控制功能

**`TCP`协议可以获取接收方当前接收数据的能力, 来调节发送方发送数据的速率**

也就是说, 如果`client`需要向`server`发送数据, `client`可以根据`server`端的接收能力, 动态调控自己发送数据的速率

但是, `client`该如何知道`server`的接受能力呢? `server`的接收能力又如何表示呢?

缓冲区是有大小的, 那么, `server`的 **接收能力 就可以通过 接收缓冲区的剩余空间大小来表示**

那么, `client`该如何获取`server`的接收缓冲区剩余空间大小呢?

`TCP`协议报头中, 有一个字段是 **16位窗口大小**, 这个 **窗口大小表示的就是接收缓冲区剩余空间的大小**

如此一来, `client`接收到`server`的应答时, 就可以获取到`server`的窗口大小, 就可以调节自己发送速率, 进而实现流量控制

即, **发送方 可以通过 读取接收方的应答报头中填充的窗口大小, 来了解接收方接受数据的能力, 然后来调控自己发送数据的能力**

> 发送方可以通过调节自己发送缓冲区的大小, 来间接调控发送数据的速率
