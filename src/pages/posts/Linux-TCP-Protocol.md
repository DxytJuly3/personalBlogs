---
layout: '../../layouts/MarkdownPost.astro'
title: '[Linux] '
pubDate: 2024-01-08
description: ''
author: '七月.cc'
cover:
    url: 'https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401080147048.webp'
    square: 'https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401080147048.webp'
    alt: 'cover'
tags: ["Linux网络", "传输层", "协议", "TCP", "约字 -- 阅读时间≈分钟"]
theme: 'light'
featured: false
---

上一篇文章, 针对`UDP`协议的格式、数据等内容做了一些简单的介绍. 并且提到, 在网络协议栈`TCP/IP`模型的传输层中, 有两个最具代表性的协议: `UDP`和`TCP`

本篇文章就简单介绍一下`TCP`协议

# `TCP`协议

`TCP`协议, 完整的称呼其实叫: **传输控制协议(Transmission Control Protocol)**

从名字就可以看出来, `TCP`协议 实际是可以对数据的传输进行详细控制的

## `TCP`协议格式

使用`TCP`协议进行通信, 操作系统会对数据添加`TCP`的协议报头, 那么`TCP`协议的格式是这样的:

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20240116205033001.webp)

可以看到, `TCP`协议报头要比`UDP`协议报头复杂的多

在介绍`UDP`协议时提到过, `TCP/IP`协议栈的每一层在进行数据传输时, 都需要考虑三个内容: **封装、解包和分用**

`TCP`协议报头中有两个熟悉的面孔: **16位源端口号 和 16位目的端口号**, 这两个数据的作用就不用多做介绍了, 是为了解决 **分用** 的问题的

### `TCP`协议的封装和解包

`UDP`协议的报头采用了8字节的固定长度, 所以可以很好的解决封装和解包的问题

而在`TCP`报文中, 我们可以看到在前`20字节`之外, 还有一个占有`n字节`的选项. 这`n字节`的部分是不固定的, 并且也属于`TCP`报头的内容

**`TCP`报头没有选项时一共`20字节`, 这20字节的数据是必须的, 被称为标准长度**

`TCP`协议在使用时, 报头的长度可能90%的情况都是标准长度(20字节). 即使选项不是必须的, 也不能忽略那`n字节`的选项长度

也就是说, **`TCP`报头的长度最少为`20字节`, 但是并不固定 可能会更大.**

既然`TCP`报头长度不固定, 那么怎么解决封装和解包的问题呢?

观察`TCP`报文格式可以发现, 在报头的`第13字节(4位空间)`处, 存储的数据表示的是 **首部长度**. 这个**首部长度, 实际就表示`TCP`协议报头的长度**

但是, 又有一个问题: `TCP`报头长度最少`20字节`, 但是报头中表示首部长度的数据只有4位, 最多也就能表示16个数据(0000~1111), 好像不太够用.

> 4位空间:
>
> `0000` `0001` `0010` `0011`
>
> `0100` `0101` `0110` `0111`
>
> `1000` `1001` `1010` `1011`
>
> `1100` `1101` `1110` `1111`

实际上是够用的, 因为 **这`4位 16个数据`的单位并不是`1字节`, 而是`4字节`. 那么也就是说, 这四位数据最多可以表示 `60字节`, 即 `TCP`首部长度最大为`60字节`**

但是, 不要忽略一个细节, `TCP`报头的标准长度为`20字节`, 也就是说最少为`20字节`. 那么, 实际上这 **4位表示首部长度的数据** 至少是`0101(5)`

既然`TCP`报头中存储有表示报头长度的数据, 那么就可以很好的解决封装和解包的问题

> 问题:
>
> `TCP`报头并没有表示报文总长度的数据, 那么接收端如何接收到报文中所包含的所有数据呢
>
> 这个问题要等到介绍网络`IP`层才会有一个答案

## `TCP`的可靠性

无论是`UDP/TCP Socket`的介绍, 还是上一篇文章中关于`UDP`协议的介绍, 文章中总提到: `UDP`协议是不可靠的, `TCP`协议是可靠的

那么, 究竟什么是不可靠? 什么是可靠?

什么是不可靠呢?

实际上我们已经提到过什么是不可靠的表现, 比如: 出现丢包、乱序、检验失败等情况, 并且不对这种情况做出处理. 这些情况, 在`UDP`协议中可能会经常出现. 不过, 既然使用了那么这些不可靠一定就不会对服务造成很大的影响

那么, 可靠就与不可靠相反了

`UDP`协议不会对丢包、检验失败等情况做出处理, 即使接收方没有正常收到数据, 接收方也不会有任何反应, 发送方更不会做出弥补. 我们说这是`UDP`协议更简单的一些代价

而`TCP`协议则不同. 使用`TCP`协议通信时, 如果出现了丢包等接收方没有收到数据的情况, `TCP`协议会有一些处理, 比如: 重传、控制流量等

那么, `TCP`协议是如何维护数据传输的可靠性的呢?

`TCP`协议会对接收方没有正常收到数据的情况做出弥补. 但是要实现这样的功能的第一个问题就是: **在这样的长距离通信中, 发送方(A)该如何确认发送的数据是丢了还是接收到了?**

答案是, **接收方(B)的回应**. 只要B收到数据之后, 给A发送一个回应, 那么A就可以确认数据已经发送到了

不过, **B发送的回应, B如何确认A是否收到了呢?**

答案是相同的, 如果 A收到B的回应之后, 再给B发送一个回应, 那么B就可以确认A收到了

就像这样:

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20240117001126901.webp)

你会发现, 如果想要做到每条消息都确定对方收到了, 是不可能的

