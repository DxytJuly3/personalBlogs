---
layout: '../../layouts/MarkdownPost.astro'
title: '[Linux] '
pubDate: 2024-01-08
description: ''
author: '七月.cc'
cover:
    url: 'https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401080147048.webp'
    square: 'https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401080147048.webp'
    alt: 'cover'
tags: ["Linux网络", "传输层", "协议", "TCP", "约字 -- 阅读时间≈分钟"]
theme: 'light'
featured: false
---

上一篇文章, 针对`UDP`协议的格式、数据等内容做了一些简单的介绍. 并且提到, 在网络协议栈`TCP/IP`模型的传输层中, 有两个最具代表性的协议: `UDP`和`TCP`

本篇文章就简单介绍一下`TCP`协议

# `TCP`协议

`TCP`协议, 完整的称呼其实叫: **传输控制协议(Transmission Control Protocol)**

从名字就可以看出来, `TCP`协议 实际是可以对数据的传输进行详细控制的

## `TCP`协议格式

使用`TCP`协议进行通信, 操作系统会对数据添加`TCP`的协议报头, 那么`TCP`协议的格式是这样的:

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20240116205033001.webp)

可以看到, `TCP`协议报头要比`UDP`协议报头复杂的多

在介绍`UDP`协议时提到过, `TCP/IP`协议栈的每一层在进行数据传输时, 都需要考虑三个内容: **封装、解包和分用**

`TCP`协议报头中有两个熟悉的面孔: **16位源端口号 和 16位目的端口号**, 这两个数据的作用就不用多做介绍了, 是为了解决 **分用** 的问题的

### `TCP`协议的封装和解包

`UDP`协议的报头采用了8字节的固定长度, 所以可以很好的解决封装和解包的问题

而在`TCP`报文中, 我们可以看到在前`20字节`之外, 还有一个占有`n字节`的选项. 这`n字节`的部分是不固定的, 并且也属于`TCP`报头的内容

**`TCP`报头没有选项时一共`20字节`, 这20字节的数据是必须的, 被称为标准长度**

`TCP`协议在使用时, 报头的长度可能90%的情况都是标准长度(20字节). 即使选项不是必须的, 也不能忽略那`n字节`的选项长度

也就是说, **`TCP`报头的长度最少为`20字节`, 但是并不固定 可能会更大.**

既然`TCP`报头长度不固定, 那么怎么解决封装和解包的问题呢?

观察`TCP`报文格式可以发现, 在报头的`第13字节(4位空间)`处, 存储的数据表示的是 **首部长度**. 这个**首部长度, 实际就表示`TCP`协议报头的长度**

但是, 又有一个问题: `TCP`报头长度最少`20字节`, 但是报头中表示首部长度的数据只有4位, 最多也就能表示16个数据(0000~1111), 好像不太够用

> 4位空间:
>
> | `0000` | `0001` | `0010` | `0011` |
>| :----: | :----: | :----: | :----: |
> | `0100` | `0101` | `0110` | `0111` |
>| `1000` | `1001` | `1010` | `1011` |
> | `1100` | `1101` | `1110` | `1111` |

实际上是够用的, 因为 **这`4位 16个数据`的单位并不是`1字节`, 而是`4字节`. 那么也就是说, 这四位数据最多可以表示 `60字节`, 即 `TCP`首部长度最大为`60字节`**

但是, 不要忽略一个细节, `TCP`报头的标准长度为`20字节`, 也就是说最少为`20字节`. 那么, 实际上这 **4位表示首部长度的数据** 至少是`0101(5)`

既然`TCP`报头中存储有表示报头长度的数据, 那么就可以很好的解决封装和解包的问题

> 问题:
>
> `TCP`报头并没有表示报文总长度的数据, 那么接收端如何接收到报文中所包含的所有数据呢
>
> 这个问题要等到介绍网络`IP`层才会有一个答案

## `TCP`的可靠性

无论是`UDP/TCP Socket`的介绍, 还是上一篇文章中关于`UDP`协议的介绍, 文章中总提到: `UDP`协议是不可靠的, `TCP`协议是可靠的

那么, 究竟什么是不可靠? 什么是可靠?

什么是不可靠呢?

实际上我们已经提到过什么是不可靠的表现, 比如: 出现丢包、乱序、检验失败等情况, 并且不对这种情况做出处理. 这些情况, 在`UDP`协议中可能会经常出现. 不过, 既然使用了那么这些不可靠一定就不会对服务造成很大的影响

那么, 可靠就与不可靠相反了

`UDP`协议不会对丢包、检验失败等情况做出处理, 即使接收方没有正常收到数据, 接收方也不会有任何反应, 发送方更不会做出弥补. 我们说这是`UDP`协议更简单的一些代价

而`TCP`协议则不同. 使用`TCP`协议通信时, 如果出现了丢包等接收方没有收到数据的情况, `TCP`协议会有一些处理, 比如: 重传、控制流量等

那么, `TCP`协议是如何维护数据传输的可靠性的呢?

### `TCP`协议的确认应答机制

`TCP`协议会对接收方没有正常收到数据的情况做出弥补. 但是要实现这样的功能的第一个问题就是: **在这样的长距离通信中, 发送方(A)该如何确认发送的数据是丢了还是接收到了?**

答案是, **接收方(B)的回应**. 只要B收到数据之后, 给A发送一个回应, 那么A就可以确认数据已经发送到了

**即, 只要发送方 收到了应答, 那么发送方就可以确认刚刚发送的消息一定已经被收到了**

不过, **B发送的回应, B如何确认A是否收到了呢?**

答案是相同的, 如果 A收到B的回应之后, 再给B发送一个回应, 那么B就可以确认A收到了

就像这样:

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/image-20240117001126901.webp)

你会发现, 如果想要做到每条消息都确定对方收到了, 是不可能的

因为 **在这样的长距离通信中, 永远有一条最新的消息是不能被确认的、没有应答的**

那么, 也就是说`TCP`协议也不是完全的可靠, 并且没有协议可以做到完全百分百的可靠

但是, `TCP`协议可以做到局部的可靠. 只要保证最新消息之前的消息都有了应答, 那么最新消息之前的数据就可以确定都已经接收到. 这就是`TCP`协议的可靠性

这样的机制, 被称为 **`TCP`协议的确认应答机制(ACK)**

---

不过, 这里又出现了其他问题: **使用`TCP`协议进行通信, 绝大多数情况下发送的报文是有很多个的. 那么,  发送方如何知道, 接收方应答的是哪一个报文呢?**

> 这个问题是什么意思呢? 
>
> `TCP`协议为了维护可靠性, 是有确认应答机制的. 不过, 在使用`TCP`进行通信时, 很可能会在短时间内发送很多个报文, 接收方实际并不会对接收到的每一个报文都单独做出应答, 而是在接收到多个报文之后, 再进行统一的应答(即, 如果短时间内发送10个报文, 接收方的应答一般不会是10个, 接收方很可能在收到多个报文之后, 才应答一次, 这样可以提高效率), 这个机制叫做 **积累确认 或 积累应答**
>
> 这样就出现了, 发送方发送了多个报文, 却只收到了一个应答 的情况. 那么, 发送方 怎么知道接收方应答的哪一个报文呢?

`TCP`协议报头中, 有两个字段: **32位序号 和 32位确认序号**. 这两个字段, 可以解决上面这个问题

`TCP`协议在发送数据 填充报头时, 会填充序号. 那么, 接收方接收到报文之后, 会根据报文的报头中填充的序号, 做出对应的应答. 即, 接收方 会在应答报文的报头中, 填充对应的确认序号

**确认序号, 一般为接收到的报文序号+1, 表示 确认序号之前的所有序号的报文都已经接收到, 也同时表示接收方期望下次开始接收报文的序号**

用图片可以很形象的表示出来:

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401171656408.webp)

同时, **接收端还可以通过接收到报文的序号对报文进行排序**, **这就是`TCP`协议报头中 32位序号 和 32位确认序号 这两个字段的作用**

从这两个序号的作用可以看出来, **发送端报头中的序号 与 接收端报头中的确认序号 是配套使用的**. 那么, 也就意味着, **同一个报文的报头中, 序号与确认序号是相互独立、互不影响的**. 这也是 **`TCP`协议全双工** 的一种体现, 因为同一个报文中的序号和确认序号是相互独立的, 所以同一个报文中可以同时填充序号和确认序号, 那么就表示这个报文在具有应答功能的同时, 还携带有数据进行发送

> 按照这样, 如果发送端发送了`1~10`序号的报文, 但是接收端只收到了`1~6`和`8~10`, 没有收到`7`
>
> 那么, 接收端应答中的 确认序号应该填充`7`, 因为`7`之前序号的报文都收到了

> `TCP`协议通信时, 报文的起始序号实际是随机的
>
> 并且, **后续的序号与 初始序号和报文数据本身 有关**
>
> **序号协定的规则是什么呢?**
>
> 首先, **起始序号是在建立连接时协定好的, 是随机的**
>
> 并且, `TCP`协议会针对 **报文数据的每一个字节进行编号**
>
> **一个报文的序号, 就表示此 报文数据的第一个字节的编号**
>
> 如果存在此次`TCP`通信的第一个报文:
>
> ![|large](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401251711659.webp)
>
> 那么上图表示的这个报文中, `7214`表示此次`TCP`通信的初始序号, 同样也表示此报文数据的第一个字节的编号, 
>
> 那么第二个报文应为:
>
> ![|wide](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401251657517.webp)
>
> 再之后的报文, 同样会按照相同的规则进行编号

### `TCP`协议的缓冲区及流量控制

在介绍`UDP`协议的文章中提到过, 无论是`UDP`协议还是`TCP`协议. 在发送报文时, 都不会直接将数据发送到网络, 而是将数据放入内核针对协议实现的 **发送缓冲区** 中(`UDP`没有真正的发送缓冲区). 接收数据也是相同的, 操作系统会将报文放入 **接收缓冲区** 中

`UDP`协议 在内核中没有实现真正的发送缓冲区, 只有接收缓冲区

而 `TCP`协议 则在内核中真正实现了 发送缓冲区和接收缓冲区

那么, 两个主机在使用`TCP`协议进行通信, 使用`write()/send()`和`read()/recv()`接口实现数据发送和接收所执行的操作, 简单理解可以看作:

![|lwide](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401251738510.webp)

> ```cpp
> ssize_t write(int fd, const void *buf, size_t count);
> ssize_t send(int sockfd, const void *buf, size_t len, int flags);
> 
> ssize_t read(int fd, void *buf, size_t count);
> ssize_t recv(int sockfd, void *buf, size_t len, int flags);
> ```
>
> 这4个系统调用, 都需要指定一个`buf`

即, 使用`TCP`协议进行通信:

调用`write()/send()`发送数据 实际 是将数据 从进程指定的缓冲区中拷贝到了内核中`TCP`的发送缓冲区

调用`read()/recv()`读取数据 实际 是将数据 从内核中`TCP`的接收缓冲区拷贝到了进程指定的缓冲区中

也就是说, `write()/send()`实际并没有将数据发送走, 而只是将数据从用户拷贝到了内核数据中

> 实际上, 常用的`I/O`类函数, 本质上都是拷贝函数
>
> 即使使用`write()`向文件内写数据, 也只是将拷贝数据交给了操作系统, 并不是直接就写入了文件内

因为, `TCP`协议在内核中实现拥有发送缓冲区和接收缓冲区并且互不干扰, 所以`TCP`协议通信是全双工的

并且, 因为`TCP`协议发送数据, 是将数据拷贝到发送缓冲区, 然后由内核中的`TCP`协议自行决策(比如: 什么时候发、发多少、要不要进行一些调整...), 所以这个协议叫做 **传输控制协议(Transmission Control Protocol)**

#### `TCP`的流量控制

`TCP`协议在内核中是拥有发送缓冲区和接收缓冲区的, 那么 既然是缓冲区, 那就一定有一定的大小

并且, `TCP`协议通信是可靠的, 那么对发送出去的数据就不能不管不顾, 不能像`UDP`那样(如果接收缓冲区满了, 再发送过来的数据报就丢掉不管了)

那么, 如果`TCP`协议发送数据过快, 导致接受方的接收缓冲区满了, 怎么办? 继续快速的发送数据, 然后接收方来不及接收 直接丢包不管吗?

`TCP`协议并不会这样. `TCP`协议为了保障通信效率, 拥有自己的流量控制功能

**`TCP`协议可以获取接收方当前接收数据的能力, 来调节发送方发送数据的速率**

也就是说, 如果`client`需要向`server`发送数据, `client`可以根据`server`端的接收能力, 动态调控自己发送数据的速率

但是, `client`该如何知道`server`的接受能力呢? `server`的接收能力又如何表示呢?

缓冲区是有大小的, 那么, `server`的 **接收能力 就可以通过 接收缓冲区的剩余空间大小来表示**

那么, `client`该如何获取`server`的接收缓冲区剩余空间大小呢?

`TCP`协议报头中, 有一个字段是 **16位窗口大小**, 这个 **窗口大小表示的就是接收缓冲区剩余空间的大小**

如此一来, `client`接收到`server`的应答时, 就可以获取到`server`的窗口大小, 就可以调节自己发送速率, 进而实现流量控制

即, **发送方 可以通过 读取接收方的应答报头中填充的窗口大小, 来了解接收方接受数据的能力, 然后来调控自己发送数据的能力**

> 问题:
>
> 既然在使用`TCP`协议正常通信时, 发送方可以通过接收方的应答报文中的窗口大小, 来获取接收方的接收能力
>
> 那么, **发送方如何在第一次发送数据之前, 就知晓接收方的窗口大小呢?**

### `TCP`报文类型 标记位

我们都知道, 在使用`TCP`协议进行通信的时候, 需要先"三次握手"建立连接, 然后才能实现正常的数据通信, 并且在通信结束的时候, 还需要"四次挥手"断开连接

为了方便`TCP`通信时需要做出一些特殊的处理, 实际上`TCP`报文是存在类型的, 针对不同类型的`TCP`报文 

`TCP`协议会做出不同的处理和响应:

1. 建立连接过程中发送的报文, `TCP`协议需要分辨出这个报文是建立连接用的, 然后会做出对应的处理与响应
2. 正常通信过程中发送的报文, `TCP`协议需要分辨出这个报文是正常通信用的, 然后会做出对应的处理与响应
3. 断开连接过程中发送的报文, `TCP`协议需要分辨出这个报文是断开连接用的, 然后会做出对应的处理与响应
4. ...

而`TCP`报文的类型, 则是通过`TCP`报头中的 **6个标记位** 来标识、分区的:

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401182201647.webp)

下面, 就来认识一下这6个标记位:

#### 1. `SYN`

这个标记位全称是`Synchronize Sequence Numbers`, 叫做 **同步标记位**

是在"三次握手"建立连接时使用的, 使用时需要将此标志位设置为1

#### 2. `FIN`

这个标记位全称是`Finish`, 叫做 **结束标记位**

是在"四次挥手"断开连接时使用的, 使用时需要将此标志位设置为1

---

`SYN`和`FIN`这两个标志位的具体使用方法, 在具体介绍 `TCP`的"三次握手"和"四次挥手"时再进行介绍

#### 3. `ACK`

这个标记位的名字, 在上面介绍`TCP`确认应答机制时见到过, 全称是`Acknowledgement Number`, 叫做 **确认标记位**

按照名字来说, 此标记位表示 该报文是对历史报文的确认, 应答报文应该设置此标记位为1. 但是, 实际上`ACK`标记位的使用 **不仅仅只能作确认用**

因为一般来说, 应答报文也是可以携带数据的, 而应答报文是需要设置`ACK`标记位的, 也就是说`ACK`标记位也允许在传输数据时设置

那么, **在`TCP`连接建立完成之后, 实际使用`TCP`协议进行通信时, 大部分的`TCP`报文都会将`ACK`标记位设置为1**

#### 4. `PSH`

这个标记位的全称是`Push Function`, 叫做 **推送标记位**

要理解这个标记位是干什么用的, 需要先介绍一些Linux操作系统`I/O`操作的特点

上面介绍过`TCP`协议是拥有接收缓冲区的, 而在`TCP`通信 调用`read()`是从`TCP`的接收缓冲区内拿数据到进程设置的缓冲区中 

而`read()`是一个阻塞式的接口, 当`TCP`接收缓冲区没有数据时, 调用`read()`的进程也好、线程也好 都会阻塞住, 直到`TCP`的接收缓冲区有数据了, `read()`才会继续执行读取数据. 这个过程中, **`read()`只有主动调用 才会检测`TCP`接收缓冲区是否有数据, 然后才会阻塞或读取数据** 的. 但是, 这样的阻塞式`I/O`并没有非常高效

所以, Linux实际提供的还有非阻塞式`I/O`接口(暂时不具体介绍). 也就是说, 应用层可以非阻塞式的从`TCP`接收缓冲区读取数据. 大概就是, 当`TCP`接收缓冲区没有数据的时候, 即使调用了非阻塞式接口, 进程或线程也不会阻塞住, 会结束执行. 而, 当`TCP`接收缓冲区中的数据大小达到一定阈值了(即让应用层读取数据的条件满足了), 内核会去通知进程或线程 可以读取数据了, 然后才会重新调用非阻塞式接口, 然后将数据读取到应用层. 也就是说, **这样的非阻塞式接口, 是不需要主动调用才能接收数据的(当然也可以主动调用), 它可以等待内核的通知, 然后再调用 实现读取数据**

而设置`PSH`标志位, 就是 **让内核通知应用层马上、尽快读取`TCP`接收缓冲区内的数据** 的. 即使`TCP`接收缓冲区中的数据大小 还没有达到需要让内核通知应用层的阈值(即, 即使让应用层读取数据的条件并没有满足)

#### 5. `URG`

这个标记位的全称是`Urgent Pointer`, 叫做 **紧急指针标记位**

我们知道, 报文在网络中路由时, 有些报文即使发送的早, 也不一定就会很早的到达接收方

那么也就是说, 在进行`TCP`通信时, 即使是按照序号的大小顺序发送的报文, 但是报文到达接收方的顺序也不一定是发送时的顺序. 即, 报文按顺序发送, 却乱序到达. 这是不可靠的一种体现, 而`TCP`协议是可靠的, 那么接收方就需要保证 接收到的数据是按照顺序的

所以, 接收方可以根据已经发送过来的报文的序号, 对报文进行排序并解包, 如果有数据没有到, 那就应答已经到了数据序号. 让后将排好顺序的报文数据再放到接收缓冲区中. 比如, 如果按照`1 2 3 4 5 6 7 8`发送数据, 数据却按照`3 2 4 1 5 7 8 6`的顺序到达了, 如果接收方当时只接受到了`3 2 4 1 5 7 8`, 还没接收到`6`, 那么就会对已经接收到的报文排序`1 2 3 4 5 7 8`, 发现`6`之前的报文都收到了, 那么接收方就会对`1~5序号`报文进行解包, 并应答确认序号`6`

这样, **`TCP`可以实现报文数据按照发送顺序到达**

但是, 这样会有另外的问题: *有些时候, 应用层需要处理的某些数据优先级比较高. 那么, 此时优先级高的数据如果还按照发送顺序进行接收, 报文到达的早还好, 如果报文到达的很晚, 好像高优先级就没有意义了*

那么, 要解决这个问题, 就需要用到`URG`标记位了

当存在紧急数据需要发送时, `TCP`协议的发送方就会设置`URG`标志位, 接收方接收到报文读取到`URG`被设置为1时, 就会选择将紧急数据存入 **外带缓冲区**. 应用层可以直接从外带缓冲区读取紧急数据, 所以紧急数据也叫做外带数据

不过, **一个报文中的紧急数据的大小只能是1字节**, 这与`TCP`报头的另一个字段有关: **16位紧急指针**

`TCP`报头中的紧急指针字段, 实际上就是指紧急数据在本报文数据中的字节偏移量, 并且 只能保存一个偏移量, 也就是说, 一个`TCP`报文中只能标识1个紧急数据. 这也是为什么紧急数据只能是1字节

---

还有一个标记位没有介绍: `RST`. 为了更加理解这个标记位, 需要先介绍一下`TCP`"三次握手"的过程

### `TCP`的"三次握手" 以及`RST`标记位

`TCP`协议是有连接的传输层协议

`TCP`协议建立连接的过程, 叫做"三次握手", 这个过程具体是什么? 为什么是三次? 这两个问题可以分析一下

`TCP`"三次握手"建立连接的过程, 用图片展示是这样的:

![|huger](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401271718575.webp)

> 注意, 通信中发送的 `SYN` `SYN+ACK` `ACK`, 并不是发送报文中携带的数据, 而是指发送的报文报头中设置的标记位

此图中, `Client`代表 **客户端** `Server`代表 **服务端**, **不同颜色的片段表示不同的状态**

那么, 这个"三次握手"的过程就是: 

1. 客户端先发送连接请求, 即 将`TCP`报文中`SYN`标记位设置为1, 然后再将整个报文发送给服务端(一般情况下不会携带数据)

    客户端发送了此报文之后, 客户端进入`SYN_SENT`状态, 表示已发送了建立连接的请求

2. 如果服务端收到了 客户端发送的连接请求, 那么服务端就会响应客户端的请求, 即 将`TCP`报文中`SYN`和`ACK`标记位都设置为1, 然后再将整个报文发送给客户端(同样一般不会携带数据)

    服务端发送了此响应报文之后, 服务端进入`SYN_RCVD`状态, 表示已经响应了客户端的连接请求

3. 然后客户端就应该收到来自服务端的响应报文, 之后 客户端就需要再向服务端发送一个响应, 即 客户端将`TCP`报文中`ACK`标记位设置为1, 然后将报文发送给服务端

    客户端发送了此次响应报文之后, 客户端就会进入`ESTABLISHED`状态, 客户端认为连接建立成功

4. 最后, 服务端应该收到来自客户端的响应, 收到之后, 服务端不会再发送响应报文, 而是进入`ESTABLISHED`状态, 服务端认为连接建立成功

"三次握手"的实际就是 客户端和服务端在互相发送报文, 用来确认连接的过程

#### 如何理解简单`TCP`的连接

`TCP`协议是面向连接的, 那么 什么是`TCP`连接呢? 如何理解`TCP`连接呢?

一个主机是可以同时建立大量的连接的, 那么操作系统就需要同时维护、管理大量的连接

按照以往操作系统管理大量进程、文件等的经验, 操作系统一定会针对每个连接 均维护 包含此连接所有属性的结构体. 不过, 由于`TCP`连接的管理较为复杂, 所以对应需要维护的结构体不止一个

那么, 也就是说, 当客户端或服务端 **为了维护`TCP`连接 创建了对应的结构体对象 并 已经完成了结构体内数据的填充**, 就表示 客户端或服务端认为此次`TCP`连接已完成且成功

#### 为什么是"三次握手"

上面 介绍了"三次握手"的过程, 但是 为什么是三次?

**一次不行吗?**

我们已经了解到, 当服务端针对此次`TCP`连接 创建并维护了对应的结构体对象 并 完成了结构体数据的填充时, 服务端就认为连接建立完成

既然是操作系统创建维护一些结构体, 那么就一定有时间和资源上的消耗

如果是"一次握手", 就表示 客户端发送`SYN`连接请求之后, 就直接认为自己创建好了连接, 服务端收到请求 不需要响应, 服务端就同样直接认为连接已建立

虽然, "一次握手"也同样可能成功的建立连接

但是, **如果只是"一次握手" 就会出现一些问题:**

1. 客户端和服务端无法正确协定、同步 双方的初始序号

    `TCP`报头存在 **序号**, 此字段的初始值是在建立连接时, 客户端和服务端互相协定、同步的

    如果只是"一次握手", 那么只能同步客户端的初始序号, 因为只有客户端发送了携带初始序号的报文

2. 由于网络延迟, 客户端可能多次发送连接请求, 服务端就有可能多次建立连接

    服务端多次建立了连接, 即 多次创建了 一些维护连接所需的结构体, 但是只有一套是有效的

    这样, 会造成对服务端资源的无效占用

**两次不行吗?**

如果是"两次握手", 就表示 客户端先发送`SYN`连接请求, 服务端收到请求 需要`SYN+ACK`响应, 然后服务端认为连接建立完成, 客户端收到服务端的响应之后, 客户端认为连接建立完成

我们知道, 客户端和服务端认为连接建立完成的标志是 系统已经创建并填充完成了 一系列维护`TCP`连接所需的结构体

那么如果"两次握手", 则是 **服务端系统先完成了 创建并填充 一系列维护连接所需的结构体**

这就可能出现一个问题: 如果客户端不断地发送请求, 但是不接收服务端的请求, 然后导致 服务端不断地 维护`TCP`连接, 而客户端并不维护连接.

这就实现了对服务端主机的攻击: **服务端会不断地消耗时间和空间资源, 用于维护`TCP`连接, 而客户端不会**

并且, 由于 **服务端依旧是 仅接收一次客户端的报文 就确认连接已建立**, 所以还可能会出现 仅"一次握手"出现的问题:

1. 由于网络延迟, 客户端可能多次发送连接请求, 服务端就有可能多次建立连接

    服务端多次建立了连接, 即 多次创建了 一些维护连接所需的结构体, 但是只有一套是有效的

    这样, 会造成对服务端资源的无效占用

> "两次握手", 理论上来说 不会出现无法协定、同步通信双方初始序号的问题
>
> 因为, 客户端发送连接请求可以携带初始序号, 服务端进行响应也可以携带初始序号
>
> 即使存在网络延迟, 导致客户端发送了多个连接请求. 服务端也会针对多个连接请求一一进行响应
>
> 所有响应报文都会填充对应的确认序号和初始序号, 所以客户端只要收到了响应报文, 就可以确认服务端响应的目标 以及 服务端的初始序号. 然后, 连接建立成功
>
> 如果, 客户端没有收到响应报文, 那这就意味着连接还没有建立成功, 客户端可能会继续发送请求, 直到成功接收响应报文

**如果是三次呢?**

"三次握手"的过程已经简单的分析了一下

![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401252027280.webp)

从图中可以看到, `Client`率先进入了`ESTABLISHED`状态, 也就是说 **`Client`率先完成了维护`TCP`连接操作**

然后, `Server`进入了`ESTABLISHED`状态, 这样 让客户端先完成维护连接的操作, 可以避免像"两次握手"那样 服务端被攻击, 至少客户端也要付出相同的代价

其次, 因为在`Client`和`Server`进入`ESTABLISHED`状态之前, 都经历了一收一发, 所以不会出现 无法正确协定和同步双方初始序号的情况

并且, "三次握手"通过三次报文传输, 顺便完成了 客户端的发送(`SYN`请求)和接收(`SYN+ACK`响应)能力的检测 以及 服务端的发送(`SYN+ACK`响应)和接收(`ACK`响应)能力的检测

"三次握手"是可以完成上面这些功能的最少的次数, 如果"四次握手"或更多次数的握手, 也只是徒增连接消耗罢了

#### 协定、同步双方初始序号

上面展示"三次握手"过程的图, 没有展示出 通信双方同步初始序号的过程

"三次握手"过程可以这样展示:

![|huge](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401252033292.webp)

> `SYN` `ACK` 大写的, 表示设置的标记位
>
> `seq` `ack` 小写的, 表示序号 和 确认序号

整个 协定、同步初始序号的过程是:

1. 客户端发送连接请求, 携带随机初始序号的`seq = x`

2. 服务端收到请求, **读取到客户端的初始序号**, 响应携带随机初始序号的`seq = y`, 且填充确认序号`ack = x+1`

3. 客户端收到响应, 读取确认序号 确认服务端已同步客户端初始序号, 同时 **读取到服务端的初始序号**, 然后 响应填充序号`seq = x+1`和确认序号`ack = y+1`

    客户端确认连接建立

4. 服务端收到响应, 读取确认序号 确认客户端已同步服务端初始序号

    服务端确认连接建立

整个过程中, **客户端和服务端, 都是经过一发一收 读取收到确认序号之后, 才确认的初始序号已同步**

"一次握手"和"两次握手"无法完善这个过程

> 了解了"三次握手"的过程, 回到上面提到的一个问题:
>
> **发送方如何在第一次发送数据之前, 就知晓接收方的窗口大小呢?**
>
> 这个答案就是: 双方会 **在"三次握手"阶段对窗口大小进行交换、同步**

#### 6. `RST`标记位

"三次握手"的过程中, 报文的发送是需要时间的

在客户端进行第三次握手之后, 客户端实际就已经认为本次`TCP`连接已经建立完成了

客户端完成连接建立之后, 会干什么? 会向服务端发送数据

但是, 有一个问题是, 如果服务端没有收到第三次握手的报文, 但是客户端已经向服务端开始发送数据了, 怎么办?

在服务端还在等待第三次握手的报文时, 服务端还没有进入`ESTABLISHED`状态, 客户端已经发送通信数据到服务端了, 此时 **服务端就会意识到 `TCP`连接出了问题**

然后 服务端就会向客户端发送 设置了`RST`标记位的报文, 让客户端重置`TCP`连接并重新进行"三次握手"

这就是`RST`标记位的作用, 让客户端重新建立`TCP`连接, 所以`RST`标记位 叫做复位标记位

> 除了上面出现的场景, `RST`还可以用于由于长时间不进行通信, 被服务器单方面断掉的`TCP`连接中

### `TCP`的超时重传机制

`TCP`的超时重传机制表示, **在`TCP`通信中, 如果一端长时间没有收到来自对端的响应, 那么就会重新发送没有收到响应的报文**

但是, 长时间没有收到对端响应有两种情况:

1. 报文根本就没有发送到对端, 在传输过程中丢包了
2. 对端接收到报文了, 并且也发送了响应报文, 但是对端的响应却在传输的过程中丢包了

这两种情况的区别是, `1. 对端没收到数据` `2. 对端收到了数据`

1. 对端没有收到数据

    此时, 只需要在超时之后 将报文重新发送给对端 就可以了

2. 对端收到了数据

    如果对端已经收到了数据, 但是对端的响应报文丢了

    那么, 当报文重新发送给对端之后, 对端会再次发送响应报文

    但是, 此时 **对端就会接收到重复的数据**. 但重复的报文、数据是没用的 需要丢弃, 所以 `TCP`协议需要有能力识别接收的报文是否重复

    这就要用到`TCP`报文的 **序号字段**. 只要两个报文的序号字段相同, 就说明收到了相同的报文

> `TCP`协议的超时重传机制, 说明了 `TCP`报文在发送出去 或 接收到之后, 并不会立刻丢弃, 而是会存储一段时间
>
> 这也是 `TCP`超时重传机制的基础

那么, **`TCP`如何界定 是否超时?**

最理想的情况, 就是可以找到一个最短的时间, 保证此次发送之后"确认应答一定能在这个时间内返回".

但是, 网络环境是会变化的, 所以这个最短的时间也是不可能固定下来的

所以`TCP`协议就需要自行的界定 超时的长度:

Linux中, 超时以`500ms`为一个单位进行控制, 每次判定超时重发的超时时间都是`500ms`的整数倍

如果重发一次之后, 仍然得不到应答, 等待`2*500ms`后再进行重传

如果仍然得不到应答, 等待`4*500ms`进行重传. 依次类推, **以指数形式递增**

累计到一定的重传次数, `TCP`认为网络或者对端主机出现异常, 强制关闭连接

> 关于超时的设定:
>
> 如果超时时间设的太长, 会影响整体的重传效率
>
> 如果超时时间设的太短, 有可能会频繁发送重复的包

### `TCP`的"四次挥手"

`TCP`协议建立连接 需要"三次握手". "三次挥手"完成之后, 连接双方就可以正常通信了

直到最后`TCP`协议断开连接 需要"四次挥手":

![|huger](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202401271707265.webp)

从图中看, `TCP`的"四次挥手", 是由 **两个主机分别发送`FIN`报文, 对端再响应`ACK`报文** 形成的

并且 可以看到:

1. 先发送`FIN`的一端(A) 在接收到对端(B)的`ACK`之后, 会进入`FIN_WAIT_2`状态, 而不是直接`CLOSED`
2. 并且, B端接收到`FIN`之后, 也没有直接响应`FIN`关闭连接. 而是, 进入了`CLOSE_WAIT`状态
3. 然后, B端才发送了`FIN`报文, 并进入`LAST_ACK`状态, 直到收到A端的`ACK`响应报文
4. A端收到B端发送的`FIN`报文, 并发送`ACK`响应报文之后, 并没有直接进入`CLOSED`状态, 而是先进入了`TIME_WAIT`状态

可以看到, `TCP`"四次挥手"的过程中, 有许多的状态:

1. 先发送`FIN`的一端, 会依次进入`FIN_WAIT_1` `FIN_WAIT_2` `TIME_WAIT`, 最后才`CLOSED`
2. 后发送的一端, 则会在接收到`FIN`之后, 依次进入`CLOSE_WAIT` `LAST_WAIT`, 然后才`COLSED`
